<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DirectoryArchiverUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deventropy Shared Utils :: Java</a> &gt; <a href="index.source.html" class="el_package">org.deventropy.shared.utils</a> &gt; <span class="el_source">DirectoryArchiverUtil.java</span></div><h1>DirectoryArchiverUtil.java</h1><pre class="source lang-java linenums">/* 
 * Copyright 2016 Development Entropy (deventropy.org) Contributors
 * 
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *  http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.deventropy.shared.utils;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.jar.Attributes;
import java.util.jar.JarFile;
import java.util.jar.Manifest;

import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveException;
import org.apache.commons.compress.archivers.ArchiveOutputStream;
import org.apache.commons.compress.archivers.ArchiveStreamFactory;
import org.apache.commons.compress.archivers.jar.JarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveOutputStream;
import org.apache.commons.compress.compressors.CompressorException;
import org.apache.commons.compress.compressors.CompressorStreamFactory;
import org.apache.commons.compress.utils.Charsets;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Utility class providing convenience methods to create Zip/Jar archives for entire directories.
 * 
 * &lt;p&gt;The functionality implemented in this class is rudimentary at this time, and does not support:
 * &lt;ul&gt;
 * 	&lt;li&gt;Compression Level&lt;/li&gt;
 * 	&lt;li&gt;Compression Method&lt;/li&gt;
 * 	&lt;li&gt;Advanced manifest manipulation (Jar files)&lt;/li&gt;
 * 	&lt;li&gt;Jar signing&lt;/li&gt;
 * 	&lt;li&gt;Filtering files out&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;h2&gt;Creating a Zip Archive&lt;/h2&gt;
 * To create a zip archive from a directory &lt;code&gt;/project/data/source&lt;/code&gt; into a file
 * &lt;code&gt;/project/data/source.zip&lt;/code&gt;, use the {@link #createZipArchiveOfDirectory(String, File, String)} as:
 * &lt;pre&gt;
 * DirectoryArchiverUtil.createJarArchiveOfDirectory(&quot;/project/data/source&quot;, &quot;/project/data/source.zip&quot;, null);
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;This will archive all the contents of the source folder recursively in the zip file created. Immediate children
 * of the source folder will be at the root of the zip file. The current implementation does not traverse down symbolic
 * links, and they will be excluded.
 * 
 * &lt;h3&gt;Nesting contents in the archive&lt;/h3&gt;
 * The implementation supports nesting contents from the source one or more directories down in the archive file
 * created. Working on the example above, if the code were invoked as:
 * &lt;pre&gt;
 * DirectoryArchiverUtil.createJarArchiveOfDirectory(&quot;/project/data/source&quot;, &quot;/project/data/source.zip&quot;, &quot;test/one&quot;);
 * &lt;/pre&gt;
 * 
 * &lt;p&gt;This will cause any files or directories which were immediate children of the source folder to appear nested under
 * directories &lt;code&gt;test/one&lt;/code&gt; in the archive (or when the archive is inflated). So
 * &lt;code&gt;/project/data/source/file.txt&lt;/code&gt; will appear at &lt;code&gt;test/one/file.txt&lt;/code&gt; in the archive.
 * 
 * &lt;h2&gt;Creating a Jar Archive&lt;/h2&gt;
 * Jar files are created almost identical to the Zip files above, with the additional functionality of a very
 * rudimentary Manifest (&lt;code&gt;META-INF/MANIFEST.MF&lt;/code&gt;) file is added to the archive with just the Manifest Version
 * property set.
 * 
 * &lt;p&gt;To create Jar files, use the {@link #createJarArchiveOfDirectory(String, File, String)} method instead.
 * 
 * &lt;p&gt;This class uses ideas expressed by user Gili on a StackOverflow question:
 * &lt;a href=&quot;http://stackoverflow.com/questions/1281229/how-to-use-jaroutputstream-to-create-a-jar-file&quot;&gt;
 * How to use JarOutputStream to create a JAR file?&lt;/a&gt;
 * 
 * @author Bindul Bhowmik
 */
public final class DirectoryArchiverUtil {
	
	private static final String DEFAULT_MANIFEST_VERSION = &quot;1.0&quot;;
	private static final String ARCHIVE_PATH_SEPARATOR = &quot;/&quot;;
	private static final String WIN_PATH_SEPARATOR = &quot;\\&quot;;
<span class="fc" id="L97">	private static final String UTF_8_NAME = Charsets.UTF_8.name();</span>
	
<span class="fc" id="L99">	private static final Logger LOG = LogManager.getLogger(DirectoryArchiverUtil.class);</span>

<span class="nc" id="L101">	private DirectoryArchiverUtil () {</span>
		// Utility class
<span class="nc" id="L103">	}</span>
	
	/**
	 * Create a zip archive with all the contents of the directory. Optionally push the contents down a directory level
	 * or two.
	 * 
	 * @param archiveFile The final archive file location. The file location must be writable.
	 * @param srcDirectory The source directory.
	 * @param rootPathPrefix The root prefix. Multiple directory parts should be separated by &lt;code&gt;/&lt;/code&gt;.
	 * @throws IOException Exception reading the source directory or writing to the destination file.
	 */
	public static void createZipArchiveOfDirectory (final String archiveFile, final File srcDirectory,
		final String rootPathPrefix) throws IOException {

<span class="fc" id="L117">		createArchiveOfDirectory(archiveFile, srcDirectory, rootPathPrefix, ArchiveStreamFactory.ZIP, UTF_8_NAME, null);</span>
<span class="fc" id="L118">	}</span>
	
	/**
	 * Create a Jar archive with all the contents of the directory. Optionally push the contents down a directory level
	 * or two. A Manifest file is automatically added.
	 * 
	 * @param archiveFile The final archive file location. The file location must be writable.
	 * @param srcDirectory The source directory.
	 * @param rootPathPrefix The root prefix. Multiple directory parts should be separated by &lt;code&gt;/&lt;/code&gt;.
	 * @throws IOException Exception reading the source directory or writing to the destination file.
	 */
	public static void createJarArchiveOfDirectory (final String archiveFile, final File srcDirectory,
		final String rootPathPrefix) throws IOException {

<span class="fc" id="L132">		createArchiveOfDirectory(archiveFile, srcDirectory, rootPathPrefix, ArchiveStreamFactory.JAR, UTF_8_NAME,</span>
				new JarArchiverCreateProcessor());
<span class="fc" id="L134">	}</span>
	
	/**
	 * Create a tar archive with all the contents of the directory. Optionally push the contents down a directory level
	 * or two.
	 * 
	 * @param archiveFile The final archive file location. The file location must be writable.
	 * @param srcDirectory The source directory.
	 * @param rootPathPrefix The root prefix. Multiple directory parts should be separated by &lt;code&gt;/&lt;/code&gt;.
	 * @throws IOException Exception reading the source directory or writing to the destination file.
	 */
	public static void createTarArchiveOfDirectory (final String archiveFile, final File srcDirectory,
		final String rootPathPrefix) throws IOException {

<span class="fc" id="L148">		createArchiveOfDirectory(archiveFile, srcDirectory, rootPathPrefix, ArchiveStreamFactory.TAR, null,</span>
				new TarArchiverCreateProcessor(null));
<span class="fc" id="L150">	}</span>
	
	/**
	 * Create a GZipped tar archive with all the contents of the directory. Optionally push the contents down a
	 * directory level or two.
	 * 
	 * @param archiveFile The final archive file location. The file location must be writable.
	 * @param srcDirectory The source directory.
	 * @param rootPathPrefix The root prefix. Multiple directory parts should be separated by &lt;code&gt;/&lt;/code&gt;.
	 * @throws IOException Exception reading the source directory or writing to the destination file.
	 */
	public static void createGZippedTarArchiveOfDirectory (final String archiveFile, final File srcDirectory,
		final String rootPathPrefix) throws IOException {

<span class="fc" id="L164">		createArchiveOfDirectory(archiveFile, srcDirectory, rootPathPrefix, ArchiveStreamFactory.TAR, null,</span>
				new TarArchiverCreateProcessor(CompressorStreamFactory.GZIP));
<span class="fc" id="L166">	}</span>
	
	private static void createArchiveOfDirectory (final String archiveFile, final File srcDirectory,
			final String rootPathPrefix, final String archiveStreamFactoryConstant, final String encoding,
			final ArchiverCreateProcessor archiverCreateProcessorIn) throws IOException {

		/*
		 * NOTE ON CHARSET ENCODING: Traditionally the ZIP archive format uses CodePage 437 as encoding for file name,
		 * which is not sufficient for many international character sets.
		 * Over time different archivers have chosen different ways to work around the limitation - the java.util.zip
		 * packages simply uses UTF-8 as its encoding for example.
		 * Ant has been offering the encoding attribute of the zip and unzip task as a way to explicitly specify the
		 * encoding to use (or expect) since Ant 1.4. It defaults to the platform's default encoding for zip and UTF-8
		 * for jar and other jar-like tasks (war, ear, ...) as well as the unzip family of tasks.
		 */
<span class="fc bfc" id="L181" title="All 2 branches covered.">		final ArchiverCreateProcessor archiveCreateProcessor = (null != archiverCreateProcessorIn)</span>
				? archiverCreateProcessorIn : new ArchiverCreateProcessor();
<span class="fc" id="L183">		ArchiveOutputStream aos = null;</span>
		try {

<span class="fc" id="L186">			final ArchiveStreamFactory archiveStreamFactory = new ArchiveStreamFactory(encoding);</span>
<span class="fc" id="L187">			final FileOutputStream archiveFileOutputStream = new FileOutputStream(archiveFile);</span>
<span class="fc" id="L188">			final OutputStream decoratedArchiveFileOutputStream = archiveCreateProcessor</span>
<span class="fc" id="L189">					.decorateFileOutputStream(archiveFileOutputStream);</span>
<span class="fc" id="L190">			aos = archiveStreamFactory.createArchiveOutputStream(archiveStreamFactoryConstant,</span>
					decoratedArchiveFileOutputStream);
<span class="fc" id="L192">			archiveCreateProcessor.processArchiverPostCreate(aos, encoding);</span>

<span class="fc bfc" id="L194" title="All 4 branches covered.">			final String normalizedRootPathPrefix = (null == rootPathPrefix || rootPathPrefix.isEmpty()) ? &quot;&quot;</span>
<span class="fc" id="L195">					: normalizeName(rootPathPrefix, true);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">			if (!normalizedRootPathPrefix.isEmpty()) {</span>
<span class="fc" id="L197">				final ArchiveEntry archiveEntry = aos.createArchiveEntry(srcDirectory, normalizedRootPathPrefix);</span>
<span class="fc" id="L198">				aos.putArchiveEntry(archiveEntry);</span>
<span class="fc" id="L199">				aos.closeArchiveEntry();</span>
			}

<span class="fc" id="L202">			final Path srcRootPath = Paths.get(srcDirectory.toURI());</span>
<span class="fc" id="L203">			final ArchiverFileVisitor visitor = new ArchiverFileVisitor(srcRootPath, normalizedRootPathPrefix, aos);</span>
<span class="fc" id="L204">			Files.walkFileTree(srcRootPath, visitor);</span>

<span class="fc" id="L206">			aos.flush();</span>
<span class="fc" id="L207">		} catch (ArchiveException e) {</span>
<span class="fc" id="L208">			throw new IOException(&quot;Error creating archive&quot;, e);</span>
		} finally {
<span class="pc bpc" id="L210" title="2 of 4 branches missed.">			if (null != aos) {</span>
<span class="pc" id="L211">				aos.close();</span>
			}
		}
<span class="fc" id="L214">	}</span>

	private static String normalizeName (final String path, final boolean isDirectory) {
<span class="fc" id="L217">		String normalizedPath = path.replace(WIN_PATH_SEPARATOR, ARCHIVE_PATH_SEPARATOR);</span>
<span class="pc bpc" id="L218" title="1 of 4 branches missed.">		if (isDirectory &amp;&amp; !normalizedPath.endsWith(ARCHIVE_PATH_SEPARATOR)) {</span>
<span class="fc" id="L219">			normalizedPath += ARCHIVE_PATH_SEPARATOR;</span>
		}
<span class="fc" id="L221">		return normalizedPath;</span>
	}
	
	private static final class ArchiverFileVisitor extends SimpleFileVisitor&lt;Path&gt; {
		private final Path sourceRootPath;
		private final String normalizedRootPathPrefix;
		private final ArchiveOutputStream archiveOutputStream;

		private ArchiverFileVisitor (final Path sourceRootPath, final String normalizedRootPathPrefix,
<span class="fc" id="L230">				final ArchiveOutputStream archiveOutputStream) {</span>
<span class="fc" id="L231">			this.normalizedRootPathPrefix = normalizedRootPathPrefix;</span>
<span class="fc" id="L232">			this.sourceRootPath = sourceRootPath;</span>
<span class="fc" id="L233">			this.archiveOutputStream = archiveOutputStream;</span>
<span class="fc" id="L234">		}</span>

		/* (non-Javadoc)
		 * @see java.nio.file.FileVisitor#preVisitDirectory(java.lang.Object,
		 * 		java.nio.file.attribute.BasicFileAttributes)
		 */
		@Override
		public FileVisitResult preVisitDirectory (final Path dir, final BasicFileAttributes attrs) throws IOException {

			// Create a zip entry for the directory
<span class="fc" id="L244">			final Path relativeSourcePath = sourceRootPath.relativize(dir);</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">			if (relativeSourcePath.toString().isEmpty()) { // Per documentation in Path, the relative path is not NULL</span>
				// Special case for the root
<span class="fc" id="L247">				return FileVisitResult.CONTINUE;</span>
			}

<span class="fc" id="L250">			final String relativeDestinationPath = normalizeName(normalizedRootPathPrefix + relativeSourcePath, true);</span>
<span class="fc" id="L251">			LOG.trace(&quot;Creating zip / jar entry for directory {} at {}&quot;, dir, relativeDestinationPath);</span>

<span class="fc" id="L253">			final ArchiveEntry archiveEntry = archiveOutputStream.createArchiveEntry(dir.toFile(),</span>
					relativeDestinationPath);
<span class="fc" id="L255">			archiveOutputStream.putArchiveEntry(archiveEntry);</span>
<span class="fc" id="L256">			archiveOutputStream.closeArchiveEntry();</span>

<span class="fc" id="L258">			return FileVisitResult.CONTINUE;</span>
		}

		/* (non-Javadoc)
		 * @see java.nio.file.FileVisitor#visitFile(java.lang.Object, java.nio.file.attribute.BasicFileAttributes)
		 */
		@Override
		public FileVisitResult visitFile (final Path file, final BasicFileAttributes attrs) throws IOException {

			// Add the file to the zip
<span class="fc" id="L268">			final Path relativeSourcePath = sourceRootPath.relativize(file);</span>
<span class="fc" id="L269">			final String relativeDestinationPath = normalizeName(normalizedRootPathPrefix + relativeSourcePath, false);</span>
<span class="fc" id="L270">			LOG.trace(&quot;Creating zip / jar entry for file {} at {}&quot;, file, relativeDestinationPath);</span>

<span class="fc" id="L272">			final ArchiveEntry archiveEntry = archiveOutputStream.createArchiveEntry(file.toFile(),</span>
					relativeDestinationPath);
<span class="fc" id="L274">			archiveOutputStream.putArchiveEntry(archiveEntry);</span>
<span class="fc" id="L275">			Files.copy(file, archiveOutputStream);</span>
<span class="fc" id="L276">			archiveOutputStream.closeArchiveEntry();</span>

<span class="fc" id="L278">			return FileVisitResult.CONTINUE;</span>
		}
	}
	
<span class="fc" id="L282">	private static class ArchiverCreateProcessor {</span>

		protected OutputStream decorateFileOutputStream (final FileOutputStream archiveFileOutputStream)
				throws IOException {
<span class="fc" id="L286">			return archiveFileOutputStream;</span>
		}

		protected void processArchiverPostCreate (final ArchiveOutputStream archiveOutputStream, final String charset)
				throws IOException {
			// Default implementation does nothing.
<span class="fc" id="L292">		}</span>
	}
	
<span class="fc" id="L295">	private static class JarArchiverCreateProcessor extends ArchiverCreateProcessor {</span>

		@Override
		protected void processArchiverPostCreate (final ArchiveOutputStream archiveOutputStream, final String charset)
				throws IOException {
<span class="fc" id="L300">			super.processArchiverPostCreate(archiveOutputStream, charset);</span>

			// Wrute the Jar Manifest file META-INF/MANIFEST.MF
<span class="fc" id="L303">			archiveOutputStream.putArchiveEntry(new JarArchiveEntry(JarFile.MANIFEST_NAME));</span>
<span class="fc" id="L304">			final Manifest manifest = new Manifest();</span>
			// Manifest-Version: 1.0
<span class="fc" id="L306">			manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, DEFAULT_MANIFEST_VERSION);</span>
<span class="fc" id="L307">			manifest.write(new BufferedOutputStream(archiveOutputStream));</span>
<span class="fc" id="L308">			archiveOutputStream.closeArchiveEntry();</span>
<span class="fc" id="L309">		}</span>
	}
	
	private static class TarArchiverCreateProcessor extends ArchiverCreateProcessor {

		private final String compressor;

<span class="fc" id="L316">		protected TarArchiverCreateProcessor (final String compressor) {</span>
<span class="fc" id="L317">			this.compressor = compressor;</span>
<span class="fc" id="L318">		}</span>

		@Override
		protected OutputStream decorateFileOutputStream (final FileOutputStream archiveFileOutputStream)
				throws IOException {
<span class="fc" id="L323">			OutputStream returnStream = super.decorateFileOutputStream(archiveFileOutputStream);</span>

<span class="fc bfc" id="L325" title="All 2 branches covered.">			if (null != compressor) {</span>
				try {
<span class="fc" id="L327">					returnStream = new CompressorStreamFactory().createCompressorOutputStream(compressor,</span>
							new BufferedOutputStream(archiveFileOutputStream));
<span class="fc" id="L329">				} catch (CompressorException e) {</span>
<span class="fc" id="L330">					throw new IOException(&quot;Error wrapping the file into a Compressed stream&quot;, e);</span>
<span class="fc" id="L331">				}</span>
			}

<span class="fc" id="L334">			return returnStream;</span>
		}

		@Override
		protected void processArchiverPostCreate (final ArchiveOutputStream archiveOutputStream, final String charset)
				throws IOException {
<span class="fc" id="L340">			super.processArchiverPostCreate(archiveOutputStream, charset);</span>
<span class="fc" id="L341">			final TarArchiveOutputStream tarArchiveOutputStream = (TarArchiveOutputStream) archiveOutputStream;</span>
<span class="fc" id="L342">			tarArchiveOutputStream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);</span>
<span class="fc" id="L343">			tarArchiveOutputStream.setAddPaxHeadersForNonAsciiNames(true);</span>
<span class="fc" id="L344">		}</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>